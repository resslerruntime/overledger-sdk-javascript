import axios from 'axios';
import OverledgerSDK from '../src';
const DltNameOptions = require('@quantnetwork/overledger-types').DltNameOptions;
const TransactionTypeOptions = require('@quantnetwork/overledger-types').TransactionTypeOptions;
const TransactionSubTypeOptions = require('@quantnetwork/overledger-types').TransactionSubTypeOptions;
const SCFunctionTypeOptions = require('@quantnetwork/overledger-types').SCFunctionTypeOptions;

jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('Dlt/Ethereum', () => {
  let overledger;
  let account;
  let signedTransaction;

  beforeAll(() => {
    overledger = new OverledgerSDK('testmappid', 'testbpikey', {
      dlts: [{ dlt: 'ethereum', }],
    });
  });

  test('Can create an account', () => {
    account = overledger.dlts.ethereum.createAccount();
    overledger.dlts.ethereum.setAccount(account.privateKey);

    expect(account.privateKey.length).toBe(66);
    expect(account.address.length).toBe(42);
  });

    //check all the required fields of the TransactionRequestObject have to be present
    test('Cannot sign an ethereum transaction without providing the dlt parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...'})).toThrow("Error parameter: dlt. Error is: All transactions must have a dlt field");
    });
  
    test('Cannot sign an ethereum transaction without providing the type parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum})).toThrow('Error parameter: type. Error is: All transactions must have a type field');
    });
  
    test('Cannot sign an ethereum transaction by providing an incorrect type parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: "..."})).toThrow('Error parameter: type. Error is: You must select a type from TransactionTypeOptions');
    });

    test('Cannot sign an ethereum transaction without providing the subType parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts})).toThrow('Error parameter: subType. Error is: All transactions must have a subType field');
    });
  
    test('Cannot sign an ethereum transaction by providing an incorrect subType parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: "..."})).toThrow('Error parameter: subType. Error is: You must select a subType from TransactionSubTypeOptions');
    });

    test('Cannot sign an ethereum transaction without providing the message parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.valueTransfer})).toThrow('Error parameter: message. Error is: All transactions must have a message field. If no message is required, assign message to the empty string, i.e. message: ""');
    });
  
    //Check all the required fields of the TransactionAccountsRequest are present
    test('Cannot sign an ethereum transaction without providing the fromAddress parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.valueTransfer, message: ""})).toThrow('Error parameter: fromAddress. Error is: All transactions for accounts distributed ledgers must have the fromAddress field');
    });
    test('Cannot sign an ethereum transaction without providing the toAddress parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.valueTransfer, message: "", fromAddress: "abcdefg"})).toThrow('Error parameter: toAddress. Error is: All transactions for accounts distributed ledgers must have the toAddress field. If you do not want to set a toAddress (maybe you are creating an on-chain smart contract?), assign toAddress to the empty string, i.e. toAddress = ""');
    });
    test('Cannot sign an ethereum transaction without providing the sequence parameter', () => {
      expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.valueTransfer, message: "", fromAddress: "abcdefg", toAddress: "pqrst"})).toThrow('Error parameter: sequence. Error is: All transactions for accounts distributed ledgers must have the sequence field as a number');
    });
  //check the required Ethereum fields and Ethereum specific validation on the above fields
  test('Cannot sign an ethereum transaction without providing the extraFields parameter', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.valueTransfer, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1})).toThrow('Error parameter: extraFields. Error is: All transactions for XRP must have the extraFields field set with feePrice and maxLedgerVersion parameters within it');
  });
  test('Cannot sign an ethereum transaction without providing the extraFields.compLimit parameter', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.valueTransfer, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, extraFields: {any: "kjhg"}})).toThrow('Error parameter: extraFields.compLimit. Error is: All transactions for Ethereum must have the extraFields.compLimit field set');
  });
  test('Cannot sign an ethereum transaction without providing the extraFields.compUnitPrice parameter', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.valueTransfer, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, extraFields: {any: "kjhg",compLimit: "1"}})).toThrow('Error parameter: extraFields.compUnitPrice. Error is: All transactions for Ethereum must have the extraFields.compUnitPrice field set');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy and no smartContract field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract. Error is: To deploy a smart contract on Ethereum, you need to define a smartContract object');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy and no smartContract.code field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "..."}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.code. Error is: To deploy a smart contract on Ethereum, you need to provide the smartContract.code field');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy and no smartContract.functionCall field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x..."}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall. Error is: To deploy a smart contract on Ethereum, you need to provide the smartContract.functionCall field');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy and no smartContract.functionCall[0].functionType field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "..."}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall[0].functionType. Error is: To deploy a smart contract on Ethereum, you need to provide the smartContract.functionCall[0].functionType field and set it equal to constructorWithNoParameters or constructorWithParameters');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy and an incorrect smartContract.functionCall[0].functionType field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...", functionType: "..."}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall[0].functionType. Error is: To deploy a smart contract on Ethereum, you need to provide the smartContract.functionCall[0].functionType field and set it equal to constructorWithNoParameters or constructorWithParameters');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy and an incorrect smartContract.functionCall[0].functionType field is provided 2', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...", functionType: SCFunctionTypeOptions.functionCallWithParameters}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall[0].functionType. Error is: To deploy a smart contract on Ethereum, you need to provide the smartContract.functionCall[0].functionType field and set it equal to constructorWithNoParameters or constructorWithParameters');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy and an incorrect smartContract.functionCall[0].functionType field is provided 3', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...", functionType: SCFunctionTypeOptions.functionCallWithNoParameters}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall[0].functionType. Error is: To deploy a smart contract on Ethereum, you need to provide the smartContract.functionCall[0].functionType field and set it equal to constructorWithNoParameters or constructorWithParameters');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy, a constructor with parameters has been called, and no smartContract.functionCall[0].inputParams field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: SCFunctionTypeOptions.constructorWithParameters}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall[0].inputParams. Error is: To deploy a smart contract on Ethereum that has parameters in its constructor, you need to provide them in the smartContract.functionCall[0].inputParams field');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractInvocation and no smartContract field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract. Error is: To invoke a smart contract on Ethereum, you need to define a smartContract object');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractInvocation and no smartContract.functionCall field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x..."}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall. Error is: To invoke a smart contract on Ethereum, you need to provide the smartContract.functionCall field');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractInvocation and no smartContract.functionCall[0].functionType field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "..."}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall[0].functionType. Error is: To invoke a smart contract on Ethereum, you need to provide the smartContract.functionCall[0].functionType field and set it equal to functionCallWithNoParameters or functionCallWithParameters');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractInvocation and no smartContract.functionCall[0].functionType parameter of the correct type is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "pqrst", sequence: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "..."}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: smartContract.functionCall[0].functionType. Error is: To invoke a smart contract on Ethereum, you need to provide the smartContract.functionCall[0].functionType field and set it equal to functionCallWithNoParameters or functionCallWithParameters');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractInvocation and no smartContract.toAddress field is provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "", sequence: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: {any: "..."}}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: toAddress. Error is: If Transaction.subType === TransactionSubTypeOptions.smartContractInvocation then a transaction.toAddress needs to be set indicating the address of the smart contract to invoke.');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and an amount is given but no payable field has been provided in smartContract.extraFields', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: {any: "..."}}]}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: extraFields.payable. Error is: If deploying or invoking a smart contract and ethereumSC.extraFields.payable === "false", then transaction.amount must be set to 0');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and an amount is given but the payable field in smartContract.extraFields is set to false', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 1, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: {any: "..."}}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: extraFields.payable. Error is: If deploying or invoking a smart contract and ethereumSC.extraFields.payable === "false", then transaction.amount must be set to 0');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any input parameters do not have a type field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "..."}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type. Error is: To invoke an Ethereum smart contract function that has input parameters, you need to provide the type field for each smart contract input parameter');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any input parameters do not have a type.selectedType field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", type: {any: "..."}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedType. Error is: To invoke a smart contract on Ethereum that has input parameters, you need to provide the selectedType field for each smart contract input parameter type, selected from TypeOptions in the Ethereum Package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any input parameters have an incorrect type.selectedType field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", type: {any: "...", selectedType: "..."}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedType. Error is: To invoke a smart contract on Ethereum that has input parameters, you need to provide the selectedType field for each smart contract input parameter type, selected from TypeOptions in the Ethereum Package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any bytes input parameters does not provide a type.selectedBytesLength field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", type: {any: "...", selectedType: "bytesB"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedBytesLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any bytes input parameters does not provide a type.selectedBytesLength field 2', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", type: {any: "...", selectedType: "bytesB[]"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedBytesLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any bytes input parameters has an incorrect type.selectedBytesLength field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...",type: {any: "...", selectedType: "bytesB", selectedBytesLength: "b"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedBytesLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any bytes input parameters has an the incorrect type.selectedBytesLength field 2', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", type: {any: "...", selectedType: "bytesB[]", selectedBytesLength: "g"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedBytesLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any input parameters do not provide a name field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].name. Error is: To invoke a smart contract on Ethereum that has input parameters, you need to provide the name field for each smart contract input parameter');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any input parameters do not provide a value field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].value. Error is: To invoke a smart contract on Ethereum that has input parameters, you need to provide the value field for each smart contract input parameter');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any integer input parameters does not provide a type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}},{any: "...", type: {any: "...", selectedType: "intB"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any integer input parameters does not provide a type.selectedIntegerLength field 2', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "2"}},{any: "...", type: {any: "...", selectedType: "intB[]"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any integer input parameters does not provide a type.selectedIntegerLength field 3', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "3"}},{any: "...", type: {any: "...", selectedType: "uintB"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any integer input parameters does not provide a type.selectedIntegerLength field 4', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "4"}},{any: "...", type: {any: "...", selectedType: "uintB[]"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any integer input parameters has an incorrect type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "intB", selectedIntegerLength: "n"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any integer input parameters has an incorrect type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "intB", selectedIntegerLength: "n"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any integer input parameters has an incorrect type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "intB", selectedIntegerLength: "n"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and any integer input parameters has an incorrect type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "intB", selectedIntegerLength: "n"}}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To invoke a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot sign an ethereum transaction if the transaction is a smartContractDeploy or a smartContractInvocation and output parameters are provided', () => {
    expect(() => overledger.dlts.ethereum.sign({any: '...', dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: "abcdefg", toAddress: "...", sequence: 1, amount: 0, smartContract:{any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", outputParams: [{any: "..."}]}], extraFields: {payable: false}}, extraFields: {any: "kjhg",compLimit: "1", compUnitPrice: "2"}})).toThrow('Error parameter: ethereumSC.functionCall[0].outputParams. Error is: To deploy or invoke a smart contract on Ethereum you should not list the output parameters');
  });
  
  test('Can sign an ethereum transaction for valueTransfer', async () => {
    signedTransaction = await overledger.dlts.ethereum.sign({dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.valueTransfer, message: "", fromAddress: account.address, toAddress: "0x635B4764D1939DfAcD3a8014726159abC277BecC", sequence: 1, amount: 20, extraFields: {compLimit: "1", compUnitPrice: "2"}});
   
    expect(signedTransaction.length).toBeGreaterThan(180);
    expect(signedTransaction.startsWith('0x')).toBe(true);
  });

  test('Can sign an ethereum transaction for smartContractDeploy', async () => {
    signedTransaction = await overledger.dlts.ethereum.sign({dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractDeploy, message: "", fromAddress: account.address, toAddress: "", sequence: 1, amount: 0, smartContract:{code: "0x1234567890abcdef", functionCall: [{functionType: SCFunctionTypeOptions.constructorWithNoParameters}], extraFields: {payable: false}}, extraFields: {compLimit: "1", compUnitPrice: "2"}});

    expect(signedTransaction.length).toBeGreaterThan(160);
    expect(signedTransaction.startsWith('0x')).toBe(true);
  });

  test('Can sign an ethereum transaction for smartContractInvocation', async () => {
    signedTransaction = await overledger.dlts.ethereum.sign({dlt: DltNameOptions.ethereum, type: TransactionTypeOptions.accounts, subType: TransactionSubTypeOptions.smartContractInvocation, message: "", fromAddress: account.address, toAddress: "0x635B4764D1939DfAcD3a8014726159abC277BecC", sequence: 1, amount: 0, smartContract:{code: "", functionCall: [{functionName: "test", functionType: SCFunctionTypeOptions.functionCallWithNoParameters, inputParams: []}], extraFields: {payable: false}}, extraFields: {compLimit: "1", compUnitPrice: "2"}});

    expect(signedTransaction.length).toBeGreaterThan(190);
    expect(signedTransaction.startsWith('0x')).toBe(true);
  });

  //now test query smart contract
  test('Cannot query an ethereum smart contract without providing a functionCall parameter', () => {
      expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...'})).toThrow("Error parameter: smartContract.functionCall. Error is: To query a smart contract, you need to provide the smartContract.functionCall field");
  });
  test('Cannot query an ethereum smart contract when providing the functionCall.code parameter', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...', code: "fdgdh"})).toThrow("Error parameter: smartContract.functionCall. Error is: To query a smart contract, you need to provide the smartContract.functionCall field");
  });
  test('Cannot query an ethereum smart contract when providing the functionCall[0].functionType parameter', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...', functionCall: [{any: ""}]})).toThrow("Error parameter: functionCall[0].functionType. Error is: The smart contract query should include a functionType");
  });
  test('Cannot query an ethereum smart contract when providing an incorrect functionCall[0].functionType parameter 1', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...', functionCall: [{any: "", functionType: SCFunctionTypeOptions.constructorWithNoParameters}]})).toThrow("Error parameter: functionCall[0].functionType. Error is: The smart contract query should include a functionType set to functionCallWithParameters or functionCallWithNoParameters");
  });
  test('Cannot query an ethereum smart contract when providing an incorrect functionCall[0].functionType parameter 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...', functionCall: [{any: "", functionType: SCFunctionTypeOptions.constructorWithParameters}]})).toThrow("Error parameter: functionCall[0].functionType. Error is: The smart contract query should include a functionType set to functionCallWithParameters or functionCallWithNoParameters");
  });
  test('Cannot query an ethereum smart contract when providing an incorrect functionCall[0].functionName parameter 1', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...', functionCall: [{any: "", functionType: SCFunctionTypeOptions.functionCallWithNoParameters}]})).toThrow("Error parameter: functionCall[0].functionName. Error is: The smart contract query should include a functionName");
  });
  test('Cannot query an ethereum smart contract when providing an incorrect functionCall[0].functionName parameter 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...', functionCall: [{any: "", functionType: SCFunctionTypeOptions.functionCallWithNoParameters}]})).toThrow("Error parameter: functionCall[0].functionName. Error is: The smart contract query should include a functionName");
  });
  test('Cannot query an ethereum smart contract with input parameters without providing functionCall[0].inputParams', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...', functionCall: [{any: "", functionType: SCFunctionTypeOptions.functionCallWithParameters, functionName: "test"}]})).toThrow("Error parameter: functionCall[0].inputParams. Error is: The smart contract query for a function call with parameters should include the functionCall[0].inputParams field");
  });
  test('Cannot query an ethereum smart contract without providing functionCall[0].outputParams', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: '...', functionCall: [{any: "", functionType: SCFunctionTypeOptions.functionCallWithNoParameters, functionName: "test"}]})).toThrow("Error parameter: functionCall[0].outputParams. Error is: The smart contract query should include the functionCall[0].outputParams field");
  });
  test('Cannot query an ethereum smart contract if provided with a code field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "0x...", functionCall: [{any: "...",functionType: "...", inputParams: [{any: "..."}]}], extraFields: {payable: false}})).toThrow('Error parameter: code. Error is: The smart contract code should be set to the empty string when querying');
  });

  //now for every input parameter to be checked
  test('Cannot query an ethereum smart contract if any input parameters do not have a type field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", inputParams: [{any: "..."}], outputParams: [{any: "..."}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type. Error is: To query an Ethereum smart contract function that has input parameters, you need to provide the type field for each smart contract input parameter');
  });
  test('Cannot query an ethereum smart contract if any input parameters do not have a type.selectedType field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", type: {any: "..."}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedType. Error is: To query a smart contract on Ethereum that has input parameters, you need to provide the selectedType field for each smart contract input parameter type, selected from TypeOptions in the Ethereum Package');
  });
  test('Cannot query an ethereum smart contract if any input parameters have an incorrect type.selectedType field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", type: {any: "...", selectedType: "..."}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedType. Error is: To query a smart contract on Ethereum that has input parameters, you need to provide the selectedType field for each smart contract input parameter type, selected from TypeOptions in the Ethereum Package');
  });
  test('Cannot query an ethereum smart contract if any bytes input parameters do not provide a type.selectedBytesLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", type: {any: "...", selectedType: "bytesB"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedBytesLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any bytes input parameters do not provide a type.selectedBytesLength field 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", type: {any: "...", selectedType: "bytesB[]"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedBytesLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any bytes input parameters has an incorrect type.selectedBytesLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...",type: {any: "...", selectedType: "bytesB", selectedBytesLength: "b"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedBytesLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any bytes input parameters has an the incorrect type.selectedBytesLength field 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", type: {any: "...", selectedType: "bytesB[]", selectedBytesLength: "g"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedBytesLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any input parameters do not provide a name field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].name. Error is: To query a smart contract on Ethereum that has input parameters, you need to provide the name field for each smart contract input parameter');
  });
  test('Cannot query an ethereum smart contract if any input parameters do not provide a value field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].value. Error is: To query a smart contract on Ethereum that has input parameters, you need to provide the value field for each smart contract input parameter');
  });
  test('Cannot query an ethereum smart contract if any integer input parameters do not provide a type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}},{any: "...", type: {any: "...", selectedType: "intB"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer input parameters does not provide a type.selectedIntegerLength field 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "2"}},{any: "...", type: {any: "...", selectedType: "intB[]"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer input parameters does not provide a type.selectedIntegerLength field 3', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "3"}},{any: "...", type: {any: "...", selectedType: "uintB"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer input parameters does not provide a type.selectedIntegerLength field 4', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "4"}},{any: "...", type: {any: "...", selectedType: "uintB[]"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer input parameters has an incorrect type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "intB", selectedIntegerLength: "n"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer input parameters has an incorrect type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "uintB", selectedIntegerLength: "n"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer input parameters has an incorrect type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "intB[]", selectedIntegerLength: "n"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer input parameters has an incorrect type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "..."}], inputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "uintB[]", selectedIntegerLength: "n"}}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].inputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has input parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });

  //now for every output parameter to be checked
  test('Cannot query an ethereum smart contract if any output parameters do not have a type field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", inputParams: [], outputParams: [{any: "..."}]}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type. Error is: To query an Ethereum smart contract function that has output parameters, you need to provide the type field for each smart contract output parameter');
  });
  test('Cannot query an ethereum smart contract if any output parameters do not have a type.selectedType field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", type: {any: "..."}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedType. Error is: To query a smart contract on Ethereum that has output parameters, you need to provide the selectedType field for each smart contract output parameter type, selected from TypeOptions in the Ethereum Package');
  });
  test('Cannot query an ethereum smart contract if any output parameters have an incorrect type.selectedType field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", type: {any: "...", selectedType: "..."}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedType. Error is: To query a smart contract on Ethereum that has output parameters, you need to provide the selectedType field for each smart contract output parameter type, selected from TypeOptions in the Ethereum Package');
  });
  test('Cannot query an ethereum smart contract if any output input parameters do not provide a type.selectedBytesLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", type: {any: "...", selectedType: "bytesB"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedBytesLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any output input parameters do not provide a type.selectedBytesLength field 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", type: {any: "...", selectedType: "bytesB[]"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedBytesLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any output input parameters has an incorrect type.selectedBytesLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...",type: {any: "...", selectedType: "bytesB", selectedBytesLength: "b"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedBytesLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any output input parameters has an the incorrect type.selectedBytesLength field 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...",type: {any: "...", selectedType: "bytesB[]", selectedBytesLength: "b"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedBytesLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are bytes, you need to provide the type.selectedBytesLength field for each byte parameter, stating how many bytes length it should use, selected from BytesBOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any output parameters do not provide a name field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].name. Error is: To query a smart contract on Ethereum that has output parameters, you need to provide the name field for each smart contract output parameter');
  });
  test('Cannot query an ethereum smart contract if any integer output parameters do not provide a type.selectedIntegerLength field', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}},{any: "...", type: {any: "...", selectedType: "intB"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer output parameters does not provide a type.selectedIntegerLength field 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}},{any: "...", type: {any: "...", selectedType: "uintB"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer output parameters does not provide a type.selectedIntegerLength field 3', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}},{any: "...", type: {any: "...", selectedType: "intB[]"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer output parameters does not provide a type.selectedIntegerLength field 4', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "1"}},{any: "...", type: {any: "...", selectedType: "uintB[]"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer output parameters has an incorrect type.selectedIntegerLength field 1', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "intB", selectedIntegerLength: "n"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer output parameters has an incorrect type.selectedIntegerLength field 2', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", name: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "uintB", selectedIntegerLength: "n"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer output parameters has an incorrect type.selectedIntegerLength field 3', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "intB[]", selectedIntegerLength: "n"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  test('Cannot query an ethereum smart contract if any integer output parameters has an incorrect type.selectedIntegerLength field 4', () => {
    expect(() => overledger.dlts.ethereum.buildSmartContractQuery("0x...", {any: "...", code: "", functionCall: [{any: "...",functionName: "test", functionType: "...", outputParams: [{any: "...", name: "...", value: "...", type: {any: "...", selectedType: "bytesB", selectedBytesLength: "5"}},{any: "...", type: {any: "...", selectedType: "uintB[]", selectedIntegerLength: "n"}}], inputParams: []}], extraFields: {payable: false}})).toThrow('Error parameter: functionCall[0].outputParams[counter].type.selectedIntegerLength. Error is: To query a smart contract on Ethereum that has output parameters, where some are integers, you need to provide the type.selectedIntegerLength field for each integer, stating how many bytes length it should use, selected from UintIntOptions in the Ethereum package');
  });
  
  /**test('Can send an ethereum signedTransaction', async () => {
    mockedAxios.post.mockResolvedValue({ status: 'broadcasted', dlt: 'ethereum', transactionHash: '0x712df767d7adea8a16aebbf080bc14daf21d3f00d3f95817db0b45abe7631711' } as any);
    const signedTransactionRequest = {
      dlt: 'ethereum',
      fromAddress: '0x0000000000000000000000000000000000000000',
      amount: 0,
      signedTransaction: {
        signatures: [],
        transactions: [signedTransaction],
      },
    }
    await overledger.dlts.ethereum.send(signedTransactionRequest);

    expect(mockedAxios.post).toBeCalledWith('/transactions', {
      mappId: 'testmappid',
      dltData: [{
        dlt: 'ethereum',
        fromAddress: expect.any(String),
        amount: expect.any(Number),
        signedTransaction: expect.any(Object),
      }],
    });
  });*/
});
